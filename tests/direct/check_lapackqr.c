//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) Peter Benner, Martin Koehler, Jens Saak and others
//               2009-2018
//

/**
 * @addtogroup test_direct
 * @{
 * @file tests/direct/check_lapackqr.c
 * @brief Check functions of @ref mess_direct_create_lapack_qr for over and underdetermined systems.
 * @author @mbehr
 * @test
 *
 * This function checks the @ref mess_matrix_pinv function defined in pinv.c.
 * It checks if
 * * \f$ @ref mess_direct_solve\f$
 * * \f$ @ref mess_direct_solvem\f$
 * * \f$ @ref mess_direct_getL\f$
 * * \f$ @ref mess_direct_getU \f$
 * for @ref MESS_REAL and @ref MESS_COMPLEX @ref MESS_DENSE matrices.
 *
 * @}
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "mess/config.h"
#include "mess/mess.h"

#include "../call_macro.h"


/**
 * @internal
 * @brief Checks @ref mess_direct_getL and @ref mess_direct_getU  function of @ref mess_direct_create_lapack_qr solver.
 * @attention Internal use only.
 */
double check_getL_getU(mess_direct solver,mess_matrix A){

    double err;
    int ret;
    mess_matrix L,U,LU;
    CALL(mess_matrix_init(&L));
    CALL(mess_matrix_init(&U));
    CALL(mess_matrix_init(&LU));
    CALL(mess_direct_getL(solver,L));
    CALL(mess_direct_getU(solver,U));
    CALL(mess_matrix_multiply(MESS_OP_NONE,L,MESS_OP_NONE,U,LU));
    CALL(mess_matrix_diffnorm(A,LU,&err));
    CALL(mess_matrix_clear(&L));
    CALL(mess_matrix_clear(&U));
    CALL(mess_matrix_clear(&LU));
    return err;
}

/**
 * @internal
 * @brief Checks @ref mess_direct_solve  function of @ref mess_direct_create_lapack_qr solver.
 *
 * Internal the functions compares the solution, with the one generated by the
 * pseudoinverse.
 * @attention Internal use only.
 */
double check_solve(mess_direct solver, mess_matrix A, mess_int_t cpx, mess_operation_t op){
    double err;
    int ret;
    mess_vector x,b,temp;

    MESS_INIT_VECTORS(&x,&b,&temp);
    CALL(mess_vector_alloc(x,(op==MESS_OP_NONE) ? A->cols : A->rows, cpx? MESS_COMPLEX:MESS_REAL));
    CALL(mess_vector_alloc(b,(op==MESS_OP_NONE) ? A->rows : A->cols, cpx? MESS_COMPLEX:MESS_REAL));
    CALL(mess_vector_alloc(temp,(op==MESS_OP_NONE) ? A->rows : A->cols,cpx? MESS_COMPLEX:MESS_REAL));

    //generate rhs vector
    CALL(mess_vector_linspace(b,0,1,b->dim));
    if(cpx){
    CALL(mess_vector_tocomplex(b));
    CALL(mess_vector_scalec(1+1*I,b));
    }

    //solve system
    CALL(mess_direct_solve(op,solver,b,x));

    //compare solution with help of pseudoinverse
    mess_matrix Pinv;
    CALL(mess_matrix_init(&Pinv));
    CALL(mess_matrix_pinv(A,Pinv));
    CALL(mess_matrix_mvp(op,Pinv,b,temp));
    CALL(mess_vector_diffnorm(temp,x,&err));

    CALL(mess_matrix_clear(&Pinv));
    CALL(mess_vector_clear(&temp));
    CALL(mess_vector_clear(&x));
    CALL(mess_vector_clear(&b));

    return err;
}

/**
 * @internal
 * @brief Checks @ref mess_direct_solvem  function of @ref mess_direct_create_lapack_qr solver.
 *
 * Internal the functions compares the solution, with the one generated by the
 * pseudoinverse.
 * @attention Internal use only.
 */
double check_solvem(mess_direct solver, mess_matrix A, mess_int_t cpx, mess_operation_t op){
    double err;
    int ret;
    mess_matrix x,b,temp;
    CALL(mess_matrix_init(&x));
    CALL(mess_matrix_init(&b));
    CALL(mess_matrix_init(&temp));

    //generate rhs vector
    mess_int_t nrhs = 3;
    if(cpx){
        CALL(mess_matrix_rand(b,(op==MESS_OP_NONE)?A->rows:A->cols,nrhs,MESS_DENSE,MESS_COMPLEX,1));
    }else{
        CALL(mess_matrix_rand(b,(op==MESS_OP_NONE)?A->rows:A->cols,nrhs,MESS_DENSE,MESS_REAL,1));
    }

    //solve system
    CALL(mess_direct_solvem(op,solver,b,x));

    //compare solution with help of pseudoinverse
    mess_matrix Pinv;
    CALL(mess_matrix_init(&Pinv));
    CALL(mess_matrix_pinv(A,Pinv));
    CALL(mess_matrix_multiply(op,Pinv,MESS_OP_NONE,b,temp));
    CALL(mess_matrix_diffnorm(temp,x,&err));

    CALL(mess_matrix_clear(&Pinv));
    CALL(mess_matrix_clear(&temp));
    CALL(mess_matrix_clear(&x));
    CALL(mess_matrix_clear(&b));

    return err;
}



int main ( int argc, char ** argv) {

    int  err=0, ret;
    double eps,diff;
    mess_matrix A;
    mess_direct solver;
    mess_operation_t op_types [] = {MESS_OP_NONE, MESS_OP_TRANSPOSE, MESS_OP_HERMITIAN};
    //mess_operation_t op_types [] = {MESS_OP_NONE};
    mess_int_t op;

    /*-----------------------------------------------------------------------------
     *  get parameters
     *-----------------------------------------------------------------------------*/
    if ( argc != 3) {
        printf("usage: %s  matrix.mtx op\n", argv[0]);
        return 1;
    }

    /*-----------------------------------------------------------------------------
     * Init/load matrices
     *-----------------------------------------------------------------------------*/
    CALL(mess_matrix_init(&A));
    CALL(mess_matrix_read (argv[1], A ));

    //make matrix rectangular
    mess_matrix_resize(A,A->rows,(mess_int_t)((A->cols+0.5)/2));
    if(atoi(argv[2])){
        //take hermitian of A
        mess_matrix AT;
        mess_matrix_init(&AT);
        mess_matrix_ctranspose(A,AT);
        mess_matrix_copy(AT,A);
        mess_matrix_clear(&AT);
    }

    eps = sqrt(mess_eps()*(A->rows)*(A->cols));
    if(A->rows < A->cols){
        printf("Underdetermined System\n");
    }else{
        printf("Overdetermined System\n");
    }

    /*-----------------------------------------------------------------------------
     *  build mess_direct_create_lapack_qr solver
     *-----------------------------------------------------------------------------*/
    CALL(mess_direct_init(&solver));
    CALL(mess_direct_create_lapack_qr(A,solver));

    /*-----------------------------------------------------------------------------
     *  check getL getU
     *-----------------------------------------------------------------------------*/
    diff = check_getL_getU(solver,A);
    printf("check_getL_getU: eps=%e \t diff=%e\n",eps,diff);
    if(diff>eps){
        printf("check_getL_getU failed with:\n");
        printf("diff=%e\n",diff);
        printf("eps=%e\n",eps);
        mess_matrix_printinfo(A);
        mess_matrix_printshort(A);
        return 1;
    }

    /*-----------------------------------------------------------------------------
     * check solve real/complex
     *-----------------------------------------------------------------------------*/
    for (op=0;op<3;++op){

        diff = check_solve(solver,A,0,op_types[op]);
        printf("check_solve (real rhs) %s: eps=%e \t diff=%e\n",mess_operation_t_str(op_types[op]),eps,diff);
        if(diff>eps){
            printf("check_solve (real) failed with:\n");
            printf("diff=%e\n",diff);
            printf("eps=%e\n",eps);
            mess_matrix_printinfo(A);
            mess_matrix_printshort(A);
            return 1;
        }

        diff = check_solve(solver,A,1,op_types[op]);
        printf("check_solve (complex rhs) %s: eps=%e \t diff=%e\n",mess_operation_t_str(op_types[op]),eps,diff);
        if(diff>eps){
            printf("check_solve (complex) failed with:\n");
            printf("diff=%e\n",diff);
            printf("eps=%e\n",eps);
            mess_matrix_printinfo(A);
            mess_matrix_printshort(A);
            return 1;
        }

    }

    /*-----------------------------------------------------------------------------
     * check solvem real/complex
     *-----------------------------------------------------------------------------*/
    for(op=0;op<3;++op){

        diff = check_solvem(solver,A,0,op_types[op]);
        printf("check_solvem (real rhs) %s: eps=%e \t diff=%e\n",mess_operation_t_str(op_types[op]),eps,diff);
        if(diff>eps){
            printf("check_solvem (real rhs) failed with:\n");
            printf("diff=%e\n",diff);
            printf("eps=%e\n",eps);
            mess_matrix_printinfo(A);
            mess_matrix_printshort(A);
            return 1;
        }

        diff = check_solvem(solver,A,1,op_types[op]);
        printf("check_solvem (complex) %s: eps=%e \t diff=%e\n",mess_operation_t_str(op_types[op]),eps,diff);
        if(diff>eps){
            printf("check_solvem (complex) failed with:\n");
            printf("diff=%e\n",diff);
            printf("eps=%e\n",eps);
            mess_matrix_printinfo(A);
            mess_matrix_printshort(A);
            return 1;
        }

    }

    /*-----------------------------------------------------------------------------
     *  clear
     *-----------------------------------------------------------------------------*/
    CALL(mess_matrix_clear(&A));
    CALL(mess_direct_clear(&solver));

    return err;
}



